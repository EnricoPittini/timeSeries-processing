

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>timeSeries_processing module &mdash; EEA-datasets-handler 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="timeSeries-processing" href="modules.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> EEA-datasets-handler
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">timeSeries-processing</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">timeSeries_processing module</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EEA-datasets-handler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="modules.html">timeSeries-processing</a> &raquo;</li>
        
      <li>timeSeries_processing module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/timeSeries_processing.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-timeSeries_processing">
<span id="timeseries-processing-module"></span><h1>timeSeries_processing module<a class="headerlink" href="#module-timeSeries_processing" title="Permalink to this headline">¶</a></h1>
<p>Module which processes time series datasets.</p>
<p>These time series are daily time series, i.e. the dates are always days. (Dates and days are used as synonyms).
Are used the pandas built-in types:</p>
<blockquote>
<div><ul class="simple">
<li><p>The dates are represented as pd.Timestamp.</p></li>
<li><p>Vectors of dates are represented as pd.DatetimeIndex.</p></li>
<li><p>The datasets are represented as pd.DataFrame, indexed by dates (i.e. the index is a pd.DatetimeIndex).</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>There are three groups of functions.</dt><dd><ol class="arabic simple">
<li><p>Functions to manipulate dates.</p></li>
<li><p>Function to plot a time series.</p></li>
<li><p>Processing functions.</p></li>
</ol>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py" id="timeSeries_processing.add_current_year_statistics">
<span class="sig-prename descclassname"><span class="pre">timeSeries_processing.</span></span><span class="sig-name descname"><span class="pre">add_current_year_statistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df_current_year</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">days_to_select</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_day</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">columns_to_select</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace_miss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_col</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#timeSeries_processing.add_current_year_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Add, to a time series DataFrame, statistics computed on the other given time series DataFrame, with respect to the
preceding days of the same year.</p>
<p><cite>df_current_year</cite> should contain days of the same year with respect to the days of <cite>df</cite>.(Nevertheless, both <cite>df</cite> and
<cite>df_current_year</cite> can contain multiple years).
Let ‘m’ be the number of the selected columns of <cite>df_current_year</cite> (by default all the columns, see the
<cite>columns_to_select</cite> parameter).
A new DataFrame is built, which is created from <cite>df</cite> adding ‘m’ new columns. (The resulting DataFrame has the same
index of <cite>df</cite>). These new ‘m’ columns contain the values computed from the associated columns of <cite>df_current_year</cite>
considering the preceding days of the same year with respect to the days in <cite>df</cite>.</p>
<p>Going into the details, let ‘day’ be a row of <cite>df</cite>, and ‘new_column’ be one of the ‘m’ new columns created
in the resulting DataFrame. The value put in that column for that day is computed from the associated column of
<cite>df_current_year</cite> considering the preceding days of the same year, in <cite>df_current_year</cite>, that are centered in ‘day’.
(See the find_current_year_days function).
Once the preceding days of the same year are selected from <cite>df_current_year</cite>, an unique value for the new column
‘new_column’ and for the day ‘day’ is computed applying a certain statistical aggregation (specified by the input
parameter <cite>stat</cite>) on the values of these selected days in the column of <cite>df_current_year</cite> associated with ‘new_column’.</p>
<p><cite>days_to_select</cite> specifies, for each ‘day’ of <cite>df</cite>, which preceding days of the same year are selected from
<cite>df_current_year</cite>. The semantics is quite similar to the parameter <cite>n_days</cite> of the find_current_year_days function (it
can either be an integer or “month” or “season”).</p>
<p>Actually, <cite>days_to_select</cite> can also be more powerful than that. <cite>days_to_select</cite> can be a predicate (i.e. a function that
returns a bool), which is used to select the same year days: for each ‘day’ of <cite>df</cite>, the preceding same year days of
<cite>df_current_year</cite> for which the function <cite>days_to_select</cite> returns True are selected.
So, <cite>days_to_select</cite> is a predicate that, in a flexible way, selects the same year days.
The signature of the function must be: (day: pd.TimeStamp, df: pd.DataFrame, current_year_day: pd.TimeStamp,
df_current_year: pd.DataFrame): bool.
Where:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>day</cite> is the current day of <cite>df</cite> ;</p></li>
<li><p><cite>df</cite> is the given DataFrame ;</p></li>
<li><p><cite>day_current_year</cite> is the preceding day of the same year contained in <cite>df_current_year</cite>;</p></li>
<li><p><cite>df_current_year</cite> is the other given DataFrame, containing days of the same year.</p></li>
</ul>
</div></blockquote>
<p>The function returns True if and only if <cite>day_current_year</cite> is a day that has to be selected for <cite>day</cite>.</p>
<p>For a certain ‘day’ of <cite>df</cite> it could happen that no preceding day of the same year is selected. This means that this
‘day’ has a missing value for each of the ‘m’ new columns (i.e. ‘m’ missing values).
In this case, if <cite>replace_miss</cite> is True, all the missing values are filled: the missing value for the new column
‘new_column’ is filled computing the mean of all the preceding days of ‘day’ in the associated column in
<cite>df_current_year</cite>. If there isn’t any preceding day in <cite>df_current_year</cite>, that ‘day’ is removed from the resulting
DataFrame (the missing values can’t be filled).
(The removed days are surely the first days in <cite>df</cite>).
Otherwise, if <cite>replace_miss</cite> is False, the ‘m’ missing values are simply kept as Nan. (No day has to be removed).</p>
<p>If <cite>current_day</cite> is True, each ‘day’ of <cite>df</cite> is itself a potential same year day that can be selected. I.e. not only the
preceding days are considered.
(This is applied also in the selection of the days to be used to fill the missing values).</p>
<p>So, in the end, ‘m’ new columns are created in the resulting DataFrame, from the selected ‘m’ columns of
<cite>df_current_year</cite>.
From the selected column with name “col” of <cite>df_current_year</cite>, the corresponding column “current_year_col” is created
in the resulting DataFrame.</p>
<p>In addition, the resulting DataFrame is automatically split into the X matrix and the y vector, which are respectively
the matrix containing the explanatory features and the vector containing the response feature.
(The response feature is the one which is the target of the prediction analysis tasks).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>df: pd.DataFrame</strong></dt><dd><p>DataFrame indexed by days (i.e. the index is a pd.DatetimeIndex).</p>
</dd>
<dt><strong>df_current_year: pd.DataFrame</strong></dt><dd><p>DataFrame indexed by days (i.e. the index is a pd.DatetimeIndex). It should contain days of the same year with
respect to the days in <cite>df</cite>.</p>
</dd>
<dt><strong>days_to_select: int or str or callable</strong></dt><dd><p>Indicates, for each day of <cite>df</cite>, which preceding days of the same year are selected in <cite>df_current_year</cite>.
It must be either an integer or “month” or “season” or a predicate (i.e. a function that returns a boolean).
The function signature must be</p>
<blockquote>
<div><p>(day: pd.TimeStamp, df: pd.DataFrame, day_current_year: pd.TimeStamp, df_current_year: pd.DataFrame): bool</p>
</div></blockquote>
</dd>
<dt><strong>current_day: bool</strong></dt><dd><p>Indicates if, each day of <cite>df</cite>, can be potentially selected for itself as a day of the same year.</p>
</dd>
<dt><strong>stat: str</strong></dt><dd><p>Indicates the statistical aggregation to perform, for each day of <cite>df</cite>, on the selected same year days of
<cite>df_current_year</cite>.
It can either be “mean” or “min” or “max”.</p>
</dd>
<dt><strong>columns_to_select: list</strong></dt><dd><p>List of strings which indicates the columns of <cite>df_current_year</cite> that have to be taken into account.
If it’s None, all the columns of <cite>df_current_year</cite> are considered.</p>
</dd>
<dt><strong>replace_miss: bool</strong></dt><dd><p>Indicates whether to fill the missing values or keep them as Nan.
(The missing values are generated for each day of <cite>df</cite> for which no same year day in <cite>df_current_year</cite> is selected).</p>
</dd>
<dt><strong>y_col: str</strong></dt><dd><p>Indicates which is the column of the resulting DataFrame to be used as y column.</p>
</dd>
<dt><strong>scale_y: bool</strong></dt><dd><p>Indicates whether to scale or not the values of the response feature y.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>pd.DataFrame</dt><dd><p>The resulting DataFrame.</p>
</dd>
<dt>X: np.array</dt><dd><p>Two-dimensional numpy array which contains the explanatory features.</p>
</dd>
<dt>y: np.array</dt><dd><p>Mono-dimensional numpy array which contains the response feature.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>When <cite>stat</cite> is neither “mean” nor “min” nor “max”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Warns</dt>
<dd class="field-even"><dl class="simple">
<dt>UserWarning</dt><dd><ul class="simple">
<li><p>When, for a day of <cite>df</cite>, no preceding day of the same year is selected from <cite>df_current_year</cite>.</p></li>
<li><p>When, for a day of <cite>df</cite>, less preceding days of the same year are found compared to the ones expected.
(This can happen only if <cite>days_to_select</cite> is either an integer or “month” or “season”).</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#timeSeries_processing.find_current_year_days" title="timeSeries_processing.find_current_year_days"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_current_year_days</span></code></a></dt><dd><p>returns, given a day, the selected preceding days of the same year.</p>
</dd>
<dt><a class="reference internal" href="#timeSeries_processing.split_X_y" title="timeSeries_processing.split_X_y"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_X_y</span></code></a></dt><dd><p>splits a DataFrame into X and y.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>If add_current_year_statistics is applied multiple times on the same <cite>df</cite> and <cite>df_current_year</cite>, columns with the same
name are potentially created.
For instance, if add_current_year_statistics is applied three times on the same DataFrames, from the <cite>df_current_year</cite>
column “col” three different columns with the same name “current_year_col” are potentially created.
To avoid that, add_current_year_statistics ensures that all the different columns with the same name are properly
disambiguated, using progressive numbers. (E.g three different columns with the same name “current_year_col” became
“current_year_col”, “current_year_col.1” and “current_year_col.2”).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="timeSeries_processing.add_k_previous_days">
<span class="sig-prename descclassname"><span class="pre">timeSeries_processing.</span></span><span class="sig-name descname"><span class="pre">add_k_previous_days</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_col</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#timeSeries_processing.add_k_previous_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Add, to a time series DataFrame, features containing values of the specified column but related to the previous days.</p>
<p>A new DataFrame is built, which is created from <cite>df</cite> adding <cite>k</cite> new columns. These <cite>k</cite> new columns contain the values
of the column <cite>col_name</cite> but with regard to, respectively: the day before; the 2-days before; … ; the k-days before.
In this way, in the resulting DataFrame for each day there is information about the feature <cite>col_name</cite> up to <cite>k</cite> days
before.
These <cite>k</cite> columns are, respectively, called: “col_name_1”, “col_name_2”, …, “col_name_k”.</p>
<p>The first <cite>k</cite> days are removed from the resulting DataFrame: that is because for the first <cite>k</cite> days there isn’t enough
information to build the new <cite>k</cite> columns.</p>
<p>In addition, the resulting DataFrame is automatically  split into the X matrix and the y vector, which are respectively
the matrix containing the explanatory features and the vector containing the response feature.
(The response feature is the one which is the  target of the prediction analysis tasks).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df: pd.DataFrame</strong></dt><dd><p>DataFrame indexed by days (i.e. the index is a pd.DatetimeIndex).</p>
</dd>
<dt><strong>col_name: str</strong></dt><dd><p>Indicates which is the column to be used to build the <cite>k</cite> new columns.</p>
</dd>
<dt><strong>k: int</strong></dt><dd><p>Indicates how many previous days are to be taken into account (i.e. how many new columns are built).</p>
</dd>
<dt><strong>y_col: str</strong></dt><dd><p>Indicates which is the column of the resulting DataFrame to be used as y column.</p>
</dd>
<dt><strong>scale_y: bool</strong></dt><dd><p>Indicates whether to scale or not the values of the response feature y.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>pd.DataFrame</dt><dd><p>The resulting DataFrame.</p>
</dd>
<dt>X: np.array</dt><dd><p>Two-dimensional numpy array which contains the explanatory features.</p>
</dd>
<dt>y: np.array</dt><dd><p>Mono-dimensional numpy array which contains the response feature.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>When <cite>df</cite> does not contain a contiguous sequence of days (i.e. there are missing days in <cite>df</cite>).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#timeSeries_processing.split_X_y" title="timeSeries_processing.split_X_y"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_X_y</span></code></a></dt><dd><p>splits a DataFrame into X and y.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="timeSeries_processing.add_k_years_ago_statistics">
<span class="sig-prename descclassname"><span class="pre">timeSeries_processing.</span></span><span class="sig-name descname"><span class="pre">add_k_years_ago_statistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df_k_years_ago</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">days_to_select</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">columns_to_select</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace_miss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_col</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#timeSeries_processing.add_k_years_ago_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Add, to a time series DataFrame, statistics computed on the other given time series DataFrame, but with respect to the
days of k years ago.</p>
<p><cite>df_k_years_ago</cite> should contain days of <cite>k</cite> years ago with respect to the days of <cite>df</cite>.(Nevertheless, both <cite>df</cite> and
<cite>df_k_years_ago</cite> can contain multiple years).
Let ‘m’ be the number of the selected columns of <cite>df_k_years_ago</cite> (by default all the columns, see the
<cite>columns_to_select</cite> parameter).
A new DataFrame is built, which is created from <cite>df</cite> adding <cite>m</cite> new columns. (The resulting DataFrame has the same
index of <cite>df</cite>). These new <cite>m</cite> columns contain the values computed from the associated columns of <cite>df_k_years_ago</cite>
considering the days of <cite>k</cite> years before the ones in <cite>df</cite>.</p>
<p>Going into the details, let ‘day’ be a row of <cite>df</cite>, and ‘new_column’ be one of the ‘m’ new columns created
in the resulting DataFrame. The value put in that column for that day is computed from the associated column of
<cite>df_k_years_ago</cite> considering the days of <cite>df_k_years_ago</cite> that are centered on <cite>day</cite> but k years ago.
(See the find_k_years_ago_days function).
Once the <cite>k</cite> years ago days in <cite>df_k_years_ago</cite> are selected, an unique value for the new column ‘new_column’ and for
the day ‘day’ is computed applying a certain statistical aggregation (specified by the input parameter <cite>stat</cite>) on the
values of these selected days in the column of <cite>df_k_years_ago</cite> associated to ‘new_column’.</p>
<p><cite>days_to_select</cite> specifies, for each ‘day’ of <cite>df</cite>, which <cite>k</cite> years ago days in <cite>df_k_years_ago</cite> are selected. The
semantics is quite similar to the parameter <cite>n_days</cite> of the find_k_years_ago_days function (it can be either an odd
integer or “month” or “season”).</p>
<p>Actually, <cite>days_to_select</cite> can also be more powerful than that. <cite>days_to_select</cite> can be a predicate (i.e a function that
returns a bool), which is used to select the days of <cite>k</cite> years ago: for each ‘day’ of <cite>df</cite>, the <cite>k</cite> years ago days
in <cite>df_k_years_ago</cite> for which the function <cite>days_to_select</cite> returns True are selected.
So, <cite>days_to_select</cite> is a predicate that, in a flexible way, selects the days of <cite>k</cite> years ago.
The signature of the function must be: (day: pd.TimeStamp, df: pd.DataFrame, k_years_ago_day: pd.TimeStamp,
df_k_years_ago: pd.DataFrame): bool.
Where:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>day</cite> is the current day of <cite>df</cite> ;</p></li>
<li><p><cite>df</cite> is the given DataFrame ;</p></li>
<li><p><cite>day_k_years_ago</cite> is the day of <cite>k</cite> years ago contained in <cite>df_k_years_ago</cite>;</p></li>
<li><p><cite>df_k_years_ago</cite> is the other given DataFrame, containing days of <cite>k</cite> years ago.</p></li>
</ul>
</div></blockquote>
<p>The function returns True if and only if <cite>day_k_years_ago</cite> is a day that has to be selected for <cite>day</cite>.</p>
<p>For a certain ‘day’ of <cite>df</cite> it could happen that no <cite>k</cite> years ago day is selected. This means that this ‘day’ has a
missing value for each of the ‘m’ new columns (i.e. ‘m’ missing values).
In this case, if <cite>replace_miss</cite> is True, all the missing values are filled: the missing value for the new column
‘new_column’ is filled computing the mean of all the values in the associated column in <cite>df_k_years_ago</cite>.
Otherwise, if <cite>replace_miss</cite> is False, the ‘m’ missing values are simply kept as Nan.</p>
<p>So, in the end, ‘m’ new columns are created in the resulting DataFrame, from the selected ‘m’ columns of
<cite>df_k_years_ago</cite>.
From the selected column with name “col” of <cite>df_k_years_ago</cite>, the corresponding column “k_years_ago_col” is created in
the resulting DataFrame.</p>
<p>In addition, the resulting DataFrame is automatically  split into the X matrix and the y vector, which are respectively
the matrix containing the explanatory features and the vector containing the response feature.
(The response feature is the one which is the target of the prediction analysis tasks).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>df: pd.DataFrame</strong></dt><dd><p>DataFrame indexed by days (i.e. the index is a pd.DatetimeIndex).</p>
</dd>
<dt><strong>df_k_years_ago: pd.DataFrame</strong></dt><dd><p>DataFrame indexed by days (i.e. the index is a pd.DatetimeIndex). It should contain days of <cite>k</cite> years ago with
respect to the days in <cite>df</cite>.</p>
</dd>
<dt><strong>k: int</strong></dt><dd><p>Indicates which previous year, with respect to the days in <cite>df</cite>, has to be taken into account (i.e. the year which is
<cite>k</cite> years ago).
It must be a positive integer.</p>
</dd>
<dt><strong>days_to_select: int or str or callable</strong></dt><dd><p>Indicates, for each day of <cite>df</cite>, which <cite>k</cite> years ago days are selected in <cite>df_k_years_ago</cite>.
It must either be an odd integer or “month” or “season” or a predicate (i.e. a function that returns a boolean).
The function signature must be</p>
<blockquote>
<div><p>(day: pd.TimeStamp, df: pd.DataFrame, day_k_years_ago: pd.TimeStamp, df_k_years_ago: pd.DataFrame): bool</p>
</div></blockquote>
</dd>
<dt><strong>stat: str</strong></dt><dd><p>Indicates the statistical aggregation to perform, for each day of <cite>df</cite>, on the selected <cite>k</cite> years ago days of
<cite>df_k_years_ago</cite>.
It can either be “mean” or “min” or “max”.</p>
</dd>
<dt><strong>columns_to_select: list</strong></dt><dd><p>List of strings which indicates the columns of <cite>df_k_years_ago</cite> that have to be taken into account.
If it’s None, all the columns of <cite>df_k_years_ago</cite> are considered.</p>
</dd>
<dt><strong>replace_miss: bool</strong></dt><dd><p>Indicates whether to fill the missing values or keep them as Nan.
(The missing values are generated for each day of <cite>df</cite> for which no <cite>k</cite> years ago day in <cite>df_k_years_ago</cite> is
selected).</p>
</dd>
<dt><strong>y_col: str</strong></dt><dd><p>Indicates which is the column of the resulting DataFrame to be used as y column.</p>
</dd>
<dt><strong>scale_y: bool</strong></dt><dd><p>Indicates whether to scale or not the values of the response feature y.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>pd.DataFrame</dt><dd><p>The resulting DataFrame.</p>
</dd>
<dt>X: np.array</dt><dd><p>Two-dimensional numpy array which contains the explanatory features.</p>
</dd>
<dt>y: np.array</dt><dd><p>Mono-dimensional numpy array which contains the response feature.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><ul class="simple">
<li><p>When <cite>k</cite> is not a positive integer.</p></li>
<li><p>When <cite>stat</cite> is neither “mean” nor “min” nor “max”.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Warns</dt>
<dd class="field-even"><dl class="simple">
<dt>UserWarning</dt><dd><ul class="simple">
<li><p>When, for a day of <cite>df</cite>, no <cite>k</cite> years ago day in <cite>df_k_years_ago</cite> is selected.</p></li>
<li><p>When, for a day of <cite>df</cite>, less <cite>k</cite> years ago days are found compared to the ones expected.
(This can happen only if <cite>days_to_select</cite> is either an odd integer or “month” or “season”).</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#timeSeries_processing.find_k_years_ago_days" title="timeSeries_processing.find_k_years_ago_days"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_k_years_ago_days</span></code></a></dt><dd><p>returns, given a day, the selected days of k years ago.</p>
</dd>
<dt><a class="reference internal" href="#timeSeries_processing.split_X_y" title="timeSeries_processing.split_X_y"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_X_y</span></code></a></dt><dd><p>splits a DataFrame into X and y.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>If add_k_years_ago_statistics is applied multiple times with the same <cite>k</cite> on the same <cite>df</cite> and <cite>df_k_years_ago</cite>,
columns with the same name are potentially created.
For instance, if add_k_years_ago_statistics is applied three times with the same <cite>k</cite> on the same DataFrames, from the
<cite>df_k_years_ago</cite> column “col” three different columns with the same name “k_years_ago_col” are potentially created.
To avoid that, add_k_years_ago_statistics ensures that all the different columns with the same name are properly
disambiguated, using progressive numbers. (E.g three different columns with the same name “k_years_ago_col”, became
“k_years_ago_col”, “k_years_ago_col.1” and “k_years_ago_col.2”).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="timeSeries_processing.add_timeSeries_dataframe">
<span class="sig-prename descclassname"><span class="pre">timeSeries_processing.</span></span><span class="sig-name descname"><span class="pre">add_timeSeries_dataframe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df_other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_col</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#timeSeries_processing.add_timeSeries_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>Add to a time series DataFrame another time series DataFrame.</p>
<p>The two DataFrames are concatenated into a new DataFrame, i.e. the resulting DataFrame contains all the columns in <cite>df</cite>
and <cite>df_other</cite>.
This concatenation is done with respect to the former DataFrame: this means that all the days of <cite>df</cite> are kept, while
only the days of <cite>df_other</cite> that are also in <cite>df</cite> are kept.</p>
<p>In addition, the resulting DataFrame is automatically  split into the X matrix and the y vector, which are respectively
the matrix containing the explanatory features and the vector containing the response feature.
(The response feature is the one which is the target of the prediction analysis tasks).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df: pd.DataFrame</strong></dt><dd><p>DataFrame indexed by days (i.e. the index is a pd.DatetimeIndex).</p>
</dd>
<dt><strong>df_other: pd.DataFrame</strong></dt><dd><p>Other DataFrame indexed by days (i.e. the index is a pd.DatetimeIndex), which has to be added to the former.</p>
</dd>
<dt><strong>y_col: str</strong></dt><dd><p>Indicates which is the column of the resulting DataFrame to be used as y column.</p>
</dd>
<dt><strong>scale_y: bool</strong></dt><dd><p>Indicates whether to scale or not the values of the response feature y.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>pd.DataFrame</dt><dd><p>The DataFrame resulting from the concatenation.</p>
</dd>
<dt>X: np.array</dt><dd><p>Two-dimensional numpy array which contains the explanatory features.</p>
</dd>
<dt>y: np.array</dt><dd><p>Mono-dimensional numpy array which contains the response feature.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#timeSeries_processing.split_X_y" title="timeSeries_processing.split_X_y"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_X_y</span></code></a></dt><dd><p>splits a DataFrame into X and y.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="timeSeries_processing.add_upTo_k_years_ago_statistics">
<span class="sig-prename descclassname"><span class="pre">timeSeries_processing.</span></span><span class="sig-name descname"><span class="pre">add_upTo_k_years_ago_statistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df_upTo_k_years_ago</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_year</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">days_to_select</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_day</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">columns_to_select</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace_miss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_col</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#timeSeries_processing.add_upTo_k_years_ago_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Add, to a time series DataFrame, statistics computed on the other given time series DataFrame, but with respect to the
days of up to k years ago.</p>
<p><cite>df_upTo_k_years_ago</cite> should contain days of up to <cite>k</cite> years ago with respect to the days of <cite>df</cite>.(Nevertheless, <cite>df</cite>
can contain multiple years).
Let ‘m’ be the number of the selected columns of <cite>df_upTo_k_years_ago</cite> (by default all the columns, see the
<cite>columns_to_select</cite> parameter).
A new DataFrame is built, which is created from <cite>df</cite> adding ‘m’ new columns. (The resulting DataFrame has the same
index of <cite>df</cite>). These new ‘m’ columns contain the values computed from the associated columns of <cite>df_upTo_k_years_ago</cite>
considering the days of up to <cite>k</cite> years before the ones in <cite>df</cite>.</p>
<p>Let ‘day’ be a row of <cite>df</cite>, and ‘new_column’ be one of the ‘m’ new columns created in the resulting DataFrame. The value
put in that column for that day is computed from the associated column of <cite>df_upTo_k_years_ago</cite> considering the days of
<cite>df_upTo_k_years_ago</cite> that are centered on <cite>day</cite> but up to <cite>k</cite> years ago.
Going into the details, for each integer ‘i’ from 1 to <cite>k</cite>, the ‘i’ years ago days centered on ‘day’ and contained
in <cite>df_upTo_k_years_ago</cite> are selected (see the find_k_years_ago_days function): from these selected ‘i’ years ago days,
an unique value is computed applying a certain statistical aggregation (specified by the input parameter <cite>stat</cite>) on the
values of these selected days in the column of <cite>df_upTo_k_years_ago</cite> associated to ‘new_column’.
In this way, for ‘day’ and ‘new_column’ <cite>k</cite> values are computed, for each integer ‘i’ from 1 to <cite>k</cite>. In the end, an
unique value for the new column ‘new_column’ and for the day ‘day’ is computed applying the same statistical aggregation
(i.e. <cite>stat</cite>) on these <cite>k</cite> values.
On the whole, an aggregation with 2 levels is computed on the days of up to <cite>k</cite> years ago with respect to ‘day’.</p>
<blockquote>
<div><ul class="simple">
<li><p>An aggregation is computed on the selected days of ‘i’ years ago days, for ‘i’ between 1 and <cite>k</cite>.</p></li>
<li><p>An aggregation is computed on the <cite>k</cite> values computed for each of the previous years, up to <cite>k</cite> years ago.</p></li>
</ul>
</div></blockquote>
<p>Basically, this is implemented by applying <cite>k</cite> times the function add_k_years_ago_statistics: for each ‘i’ between 1 and
<cite>k</cite>, add_k_years_ago_statistics is applied with his input parameter ‘k’ equal to ‘i’.
add_k_years_ago_statistics is applied on all the previous years, up to <cite>k</cite> years ago.
So, add_upTo_k_years_ago_statistics is nothing else than an extension of the add_k_years_ago_statistics function.
(See add_k_years_ago_statistics).
The meaning of the input parameters <cite>days_to_select</cite>, <cite>stat</cite>, <cite>replace_miss</cite>, …, are the same of the ones seen in
add_k_years_ago_statistics.</p>
<p>In particular, <cite>days_to_select</cite> specifies, for each ‘day’ of <cite>df</cite>, which ‘i’ years ago days in <cite>df_upTo_k_years_ago</cite> are
selected, for ‘i’ from 1 to <cite>k</cite>. It can either be an odd integer or “month” or “season” or a predicate (i.e. a function
that returns a bool).
The signature of the function must be:</p>
<blockquote>
<div><p>(day: pd.TimeStamp, df: pd.DataFrame, day_i_years_ago: pd.TimeStamp, df_upTo_k_years_ago: pd.DataFrame): bool.</p>
</div></blockquote>
<p>If <cite>current_year</cite> is True, also the current year is taken into account, and not only the preceding years up to <cite>k</cite> years
ago.
This means that, for each ‘day’ of <cite>df</cite>, <cite>k`+1 values are computed: from the current year; from the previous year; …;
from `k</cite> years ago. These <cite>k`+1 values are aggregated in a single value.
The value computed from the current year is calculated using the add_current_year_statistics function (see
add_current_year_statistics).
The meaning of the input parameters `days_to_select</cite>, <cite>current_day</cite>, <cite>stat</cite>, <cite>replace_miss</cite>, …, are the same as the
ones seen in add_current_year_statistics.
(If <cite>current_year</cite> is True, add_current_year_statistics is applied one time and then add_k_years_ago_statistics is
applied <cite>k</cite> times).</p>
<p>So, in the end, ‘m’ new columns are created in the resulting DataFrame, from the selected ‘m’ columns of
<cite>df_upTo_k_years_ago</cite>.
From the selected column with name “col” of <cite>df_upTo_k_years_ago</cite>, the corresponding  column “upTo_k_years_ago_col” is
created in the resulting DataFrame.</p>
<p>In addition, the resulting DataFrame is automatically  split into the X matrix and the y vector, which are respectively
the matrix containing the explanatory features and the vector containing the response feature.
(The response feature is the one which is the target of the prediction analysis tasks).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df: pd.DataFrame</strong></dt><dd><p>DataFrame indexed by days (i.e. the index is a pd.DatetimeIndex).</p>
</dd>
<dt><strong>df_upTo_k_years_ago: pd.DataFrame</strong></dt><dd><p>DataFrame indexed by days (i.e. the index is a pd.DatetimeIndex). It should contain up to <cite>k</cite> years ago days with
respect to the days in <cite>df</cite>.</p>
</dd>
<dt><strong>k: int</strong></dt><dd><p>Indicates how many previous years have to be taken into account (i.e. all the previous years up to <cite>k</cite> years ago are
taken into account).
It must be a positive integer.</p>
</dd>
<dt><strong>current_year: bool</strong></dt><dd><p>Indicates whether to consider also the current year or not: in the former case are taken into account all the years
from the current up to <cite>k</cite> years ago.</p>
</dd>
<dt><strong>days_to_select: int or str or callable</strong></dt><dd><p>Indicates, for each day of <cite>df</cite>, which days in <cite>df_upTo_k_years_ago</cite> have to be selected, for each year from the
previous up to <cite>k</cite> years ago.
It must either be an odd integer or “month” or “season” or a predicate (i.e. a function that returns a boolean).
If <cite>current_year</cite> is True, this selection is also applied on the days of the same year.</p>
</dd>
<dt><strong>current_day: bool</strong></dt><dd><p>Indicates if each day of <cite>df</cite> can be potentially selected for itself as a day of the same year.
This parameter is considered only if <cite>current_year</cite> is True.</p>
</dd>
<dt><strong>stat: str</strong></dt><dd><p>Indicates the statistical aggregation to perform. It can either be “mean” or “min” or “max”.
This aggregation is applied in two levels: both for each previous year (up to <cite>k</cite> years ago) and for the aggregation
of the <cite>k</cite> computed values (<cite>k`+1 if `current_year</cite> is True).</p>
</dd>
<dt><strong>columns_to_select: list</strong></dt><dd><p>List of strings which indicates the columns of <cite>df_upTo_k_years_ago</cite> that have to be taken into account.
If it is None, all the columns of <cite>df_upTo_k_years_ago</cite> are considered.</p>
</dd>
<dt><strong>replace_miss: bool</strong></dt><dd><p>Indicates whether to fill the missing values.</p>
</dd>
<dt><strong>y_col: str</strong></dt><dd><p>Indicates which is the column of the resulting DataFrame to be used as y column.</p>
</dd>
<dt><strong>scale_y: bool</strong></dt><dd><p>Indicates whether to scale or not the values of the response feature y.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>pd.DataFrame</dt><dd><p>The resulting DataFrame.</p>
</dd>
<dt>X: np.array</dt><dd><p>Two-dimensional numpy array which contains the explanatory features.</p>
</dd>
<dt>y: np.array</dt><dd><p>Mono-dimensional numpy array which contains the response feature.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><ul class="simple">
<li><p>When <cite>k</cite> is not a positive integer.</p></li>
<li><p>When <cite>stat</cite> is neither “mean” nor “min” nor “max”.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#timeSeries_processing.find_k_years_ago_days" title="timeSeries_processing.find_k_years_ago_days"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_k_years_ago_days</span></code></a></dt><dd><p>returns, given a day, the selected days of k years ago.</p>
</dd>
<dt><a class="reference internal" href="#timeSeries_processing.add_k_years_ago_statistics" title="timeSeries_processing.add_k_years_ago_statistics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_k_years_ago_statistics</span></code></a></dt><dd><p>adds, to a time series DataFrame, statistics computed on the other given time series DataFrame, but with respect to the days of k years ago.</p>
</dd>
<dt><a class="reference internal" href="#timeSeries_processing.find_current_year_days" title="timeSeries_processing.find_current_year_days"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_current_year_days</span></code></a></dt><dd><p>returns, given a day, the selected preceding days of the same year.</p>
</dd>
<dt><a class="reference internal" href="#timeSeries_processing.add_current_year_statistics" title="timeSeries_processing.add_current_year_statistics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_current_year_statistics</span></code></a></dt><dd><p>adds, to a time series DataFrame, statistics computed on the other given time series DataFrame, with respect to the preceding days of the same year.</p>
</dd>
<dt><a class="reference internal" href="#timeSeries_processing.split_X_y" title="timeSeries_processing.split_X_y"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_X_y</span></code></a></dt><dd><p>splits a DataFrame into X and y.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If add_upTo_k_years_ago_statistics is applied multiple times with the same <cite>k</cite> on the same <cite>df</cite> and
<cite>df_upTo_k_years_ago</cite>, columns with the same name are potentially created.
For instance, if add_upTo_k_years_ago_statistics is applied three times with the same <cite>k</cite> on the same DataFrames,
from the <cite>df_upTo_k_years_ago</cite> column “col” three different columns with the same name “upTo_k_years_ago_col” are
potentially created.
To avoid that, add_upTo_k_years_ago_statistics ensures that all the different columns with the same name are properly
disambiguated, using progressive numbers. (E.g three different columns with same name “upTo_k_years_ago_col” became
“upTo_k_years_ago_col”, “upTo_k_years_ago_col.1” and “upTo_k_years_ago_col.2”).</p></li>
<li><p>The meaning of <cite>replace_miss</cite> is the same seen in add_k_years_ago_statistics. For each previous year up to <cite>k</cite> years
ago, if no selected day is found and <cite>replace_miss</cite> is True, the mean of the whole <cite>df_upTo_k_years_ago</cite> DataFrame is
computed: this is the value calculated for that year (value that will be aggregated with the other <cite>k</cite> values).
This same concept is valid also for the current year, if <cite>current_year</cite> is True.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="timeSeries_processing.find_current_year_days">
<span class="sig-prename descclassname"><span class="pre">timeSeries_processing.</span></span><span class="sig-name descname"><span class="pre">find_current_year_days</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">day</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_days</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_day</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#timeSeries_processing.find_current_year_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return, given a day, the preceding days of the same year which are centered on that day.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>day: pd.Timestamp</strong></dt><dd></dd>
<dt><strong>n_days: int or str</strong></dt><dd><dl class="simple">
<dt>Indicates specifically which are the current year days to select.</dt><dd><ul class="simple">
<li><p>If it’s an int, the <cite>n_days</cite> preceding <cite>day</cite> are selected.</p></li>
<li><p>If it’s a str, it must be either “month” or “season”. All the days in the same month/season that
precede <cite>day</cite> are selected.
(The meteorological seasons are considered, and not the astronomical ones)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>current_day: bool</strong></dt><dd><p>Indicates whether to select also the current day (i.e. <cite>day</cite>) or not.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>pd.DatetimeIndex</dt><dd><p>Vector of the selected days.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>When <cite>n_days</cite> is neither an integer nor “month” nor “season”.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="timeSeries_processing.find_k_years_ago_days">
<span class="sig-prename descclassname"><span class="pre">timeSeries_processing.</span></span><span class="sig-name descname"><span class="pre">find_k_years_ago_days</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">day</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_days</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#timeSeries_processing.find_k_years_ago_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return, given a day, the days which are centered on that day but k years ago.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>day: pd.Timestamp</strong></dt><dd></dd>
<dt><strong>k: int</strong></dt><dd><p>Indicates which past year has to be considered (i.e. <cite>k</cite> years ago).</p>
</dd>
<dt><strong>n_days: int or str</strong></dt><dd><dl class="simple">
<dt>Indicates specifically which are the <cite>k</cite> years ago to select.</dt><dd><ul class="simple">
<li><p>If it’s an int, it must be an odd positive number. The <cite>n_days</cite> centered on <cite>day</cite> but <cite>k</cite> years
ago are selected .</p></li>
<li><p>If it’s a str, it must be either “month” or “season”. All the days in the same month/season but
<cite>k</cite> years ago are selected.
(The meteorological seasons are considered, and not the astronomical ones)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>pd.DatetimeIndex</dt><dd><p>Vector of the selected days.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>When <cite>n_days</cite> is neither an odd positive integer nor “month” nor “season”.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="timeSeries_processing.find_missing_days">
<span class="sig-prename descclassname"><span class="pre">timeSeries_processing.</span></span><span class="sig-name descname"><span class="pre">find_missing_days</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">days</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#timeSeries_processing.find_missing_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return, given a vector of days, his missing days.</p>
<p>More specifically, the missing days are the ones which are not present in the contiguous sequence of days in <cite>days</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>days: pd.DatetimeIndex</strong></dt><dd><p>Vector of dates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>pd.DatetimeIndex</dt><dd><p>Vector of missing days.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="timeSeries_processing.find_same_month_days">
<span class="sig-prename descclassname"><span class="pre">timeSeries_processing.</span></span><span class="sig-name descname"><span class="pre">find_same_month_days</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">day</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#timeSeries_processing.find_same_month_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return, given a day, all the days which are in the same month.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>day: pd.Timestamp</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>pd.DatetimeIndex</dt><dd><p>Vector of the days in the same month.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="timeSeries_processing.find_same_season_days">
<span class="sig-prename descclassname"><span class="pre">timeSeries_processing.</span></span><span class="sig-name descname"><span class="pre">find_same_season_days</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">day</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#timeSeries_processing.find_same_season_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return, given a day, all the days which are in the same season.</p>
<p>The meteorological seasons are considered, and not the astronomical ones.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>day: pd.Timestamp</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>pd.DatetimeIndex</dt><dd><p>Vector of the days in the same season.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="timeSeries_processing.group_days_by">
<span class="sig-prename descclassname"><span class="pre">timeSeries_processing.</span></span><span class="sig-name descname"><span class="pre">group_days_by</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">days</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#timeSeries_processing.group_days_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Group the given vector of days according to the given criterion.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>days: pd.DatetimeIndex</strong></dt><dd></dd>
<dt><strong>criterion: str</strong></dt><dd><p>Indicates how to group the given days. It can be either “year” or “month” or “season”.
(The meteorological seasons are considered, and not the astronomical ones)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>list</dt><dd><p>List of pairs (i.e. tuples).
Each pair is a group of days.</p>
<blockquote>
<div><ul class="simple">
<li><p>The first element is a string which represents the group name (i.e. group label).</p></li>
<li><p>The second element is the vector of days in that group, i.e. it’s a pd.DatetimeIndex.</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>When <cite>criterion</cite> is neither “year” nor “month” nor “season”.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For the sake of completeness, it’s important to say that if <cite>criterion</cite> is either “month” or “season”, also days of
different years could be grouped together.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="timeSeries_processing.plot_timeSeries">
<span class="sig-prename descclassname"><span class="pre">timeSeries_processing.</span></span><span class="sig-name descname"><span class="pre">plot_timeSeries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">divide</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Days'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Time</span> <span class="pre">series</span> <span class="pre">values'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(9,</span> <span class="pre">9)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#timeSeries_processing.plot_timeSeries" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a column of the given time series DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df: pd.DataFrame</strong></dt><dd><p>DataFrame indexed by days (i.e. the index is a pd.DatetimeIndex).</p>
</dd>
<dt><strong>col_name: str</strong></dt><dd><p>Indicates the specified column to plot.</p>
</dd>
<dt><strong>divide: str</strong></dt><dd><p>Indicates if and how to divide the plotted values.
It can either be None, “year”, “month” or “season”. (The meteorological seasons are considered, and not the
astronomical ones).
That division is simply made graphically using different colors.</p>
</dd>
<dt><strong>xlabel: str</strong></dt><dd><p>Label to put on the x axis.</p>
</dd>
<dt><strong>line: bool</strong></dt><dd><p>Indicates whether to connect the points with a line.</p>
</dd>
<dt><strong>title: str</strong></dt><dd><p>Title of the plot.</p>
</dd>
<dt><strong>figsize: tuple</strong></dt><dd><p>Dimensions of the plot.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>matplotlib.axes.Axes</dt><dd><p>The matplotlib Axes where the plot has been made.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="timeSeries_processing.split_X_y">
<span class="sig-prename descclassname"><span class="pre">timeSeries_processing.</span></span><span class="sig-name descname"><span class="pre">split_X_y</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_col</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#timeSeries_processing.split_X_y" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the given DataFrame into X and y.</p>
<p>X is a matrix which contains the explanatory variables of <cite>df</cite>, y is a vector which contains the response variable of
<cite>df</cite> (i.e. the variable which is the target of the prediction analysis tasks).
Optionally, the values in y can be scaled.</p>
<p>This function is an auxiliary utility for the processing functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df: pd.DataFrame</strong></dt><dd></dd>
<dt><strong>y_col: str</strong></dt><dd><p>Indicates which is the <cite>df</cite> column that is the response feature.
If it is None, the last <cite>df</cite> column is considered.</p>
</dd>
<dt><strong>scale_y: bool</strong></dt><dd><p>Indicates whether to scale or not the values in y.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>X: np.array</dt><dd><p>Two-dimensional np.array, containing the explanatory features of <cite>df</cite>.</p>
</dd>
<dt>y: np.array</dt><dd><p>Mono dimensional np.array, containing the response feature of <cite>df</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The scaling of the values in y is performed using the sklearn MinMaxScaler.</p>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="modules.html" class="btn btn-neutral float-left" title="timeSeries-processing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Enrico Pittini.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>